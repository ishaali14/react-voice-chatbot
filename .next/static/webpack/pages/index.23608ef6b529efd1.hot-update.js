"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./components/CallManager.tsx":
/*!************************************!*\
  !*** ./components/CallManager.tsx ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCallManager: function() { return /* binding */ useCallManager; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_speech_recognition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-speech-recognition */ \"./node_modules/react-speech-recognition/lib/index.js\");\n/* harmony import */ var next_i18next__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next-i18next */ \"./node_modules/next-i18next/dist/esm/index.js\");\n/* harmony import */ var _LanguageManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./LanguageManager */ \"./components/LanguageManager.tsx\");\n/* harmony import */ var _callUtil__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./callUtil */ \"./components/callUtil.ts\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n\nconst CallContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst CallManager = (param)=>{\n    let { children } = param;\n    _s();\n    const isUserCalling = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const isChatbotSpeaking = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const speechUtteranceRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const pauseTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const lastTranscriptRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(\"\");\n    const [pauseThreshold, setPauseThreshold] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(2); // Default 2 seconds\n    // Track if we're handling an interruption\n    const isHandlingInterruption = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    // Keep track of when bot started speaking to implement cooldown period\n    const botSpeechStartTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const cooldownPeriodMs = 700; // Cooldown after bot starts speaking\n    // Reference to AudioContext and nodes for echo cancellation\n    const audioContextRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const speechDetectorRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const isUserSpeakingRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    // Energy threshold for distinguishing between user and bot speech\n    const energyThresholdRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0.12);\n    // Add a reference for the current speech content to help with fingerprinting\n    const currentSpeechContentRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(\"\");\n    const commands = [\n        {\n            command: [\n                \"*\"\n            ],\n            callback: (command)=>{\n                // Only process command when a significant change occurs\n                if (command.trim() && command !== lastTranscriptRef.current) {\n                    handleUserSpeech(command);\n                }\n            }\n        }\n    ];\n    const [isWinSpeaking, setIsWinSpeaking] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(isChatbotSpeaking.current);\n    const [isCalling, setIsCalling] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(isUserCalling.current);\n    const { transcript, resetTranscript, listening } = (0,react_speech_recognition__WEBPACK_IMPORTED_MODULE_2__.useSpeechRecognition)({\n        commands\n    });\n    const { t } = (0,next_i18next__WEBPACK_IMPORTED_MODULE_3__.useTranslation)();\n    const [userSpeechSynthesis, setUserSpeechSynthesis] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    const [userLocalStorage, setUserLocalStorage] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    const { selectedLanguage } = (0,_LanguageManager__WEBPACK_IMPORTED_MODULE_4__.useLanguage)();\n    const defaultIntroduction = t(\"Win.introduction\");\n    const defaultMessage = [\n        {\n            message: defaultIntroduction,\n            sender: \"ChatGPT\"\n        }\n    ];\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(defaultMessage);\n    // Initialize audio context when component mounts\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (true) {\n            try {\n                const AudioContext = window.AudioContext || window.webkitAudioContext;\n                audioContextRef.current = new AudioContext();\n                setupAudioProcessing();\n            } catch (error) {\n                console.error(\"Error initializing AudioContext:\", error);\n            }\n        }\n        return ()=>{\n            // Clean up audio context when component unmounts\n            if (audioContextRef.current && audioContextRef.current.state !== \"closed\") {\n                audioContextRef.current.close();\n            }\n        };\n    }, []);\n    // Set up audio processing for speech detection with echo cancellation\n    const setupAudioProcessing = async ()=>{\n        if (!audioContextRef.current) return;\n        try {\n            // Get user microphone access\n            const stream = await navigator.mediaDevices.getUserMedia({\n                audio: {\n                    echoCancellation: true,\n                    noiseSuppression: true,\n                    autoGainControl: true // Enable automatic gain control\n                }\n            });\n            // Create audio source from microphone\n            const micSource = audioContextRef.current.createMediaStreamSource(stream);\n            // Create script processor for analyzing audio\n            const processor = audioContextRef.current.createScriptProcessor(4096, 1, 1);\n            speechDetectorRef.current = processor;\n            micSource.connect(processor);\n            // Process audio data to detect speech with enhanced echo cancellation\n            processor.onaudioprocess = (e)=>{\n                if (isChatbotSpeaking.current) {\n                    // Skip processing during the cooldown period\n                    const timeSinceBotStarted = Date.now() - botSpeechStartTimeRef.current;\n                    if (timeSinceBotStarted < cooldownPeriodMs) {\n                        return;\n                    }\n                    const input = e.inputBuffer.getChannelData(0);\n                    // Calculate audio energy in human speech frequency range\n                    const speechEnergy = calculateSpeechEnergy(input);\n                    // If energy exceeds threshold, likely user is speaking\n                    if (speechEnergy > energyThresholdRef.current) {\n                        if (!isUserSpeakingRef.current) {\n                            isUserSpeakingRef.current = true;\n                            // Add debounce to prevent false triggers\n                            setTimeout(()=>{\n                                if (isUserSpeakingRef.current) {\n                                    console.log(\"User interrupted - human speech detected\");\n                                    handleInterruption();\n                                }\n                            }, 180); // Wait 180ms to confirm consistent speech\n                        }\n                    } else {\n                        isUserSpeakingRef.current = false;\n                    }\n                }\n            };\n            // Connect but with gain node to control volume going to output\n            const gainNode = audioContextRef.current.createGain();\n            gainNode.gain.value = 0; // Set to 0 to prevent audio feedback to speakers\n            processor.connect(gainNode);\n            gainNode.connect(audioContextRef.current.destination);\n            // Disconnect when not needed\n            if (!isChatbotSpeaking.current) {\n                processor.disconnect();\n            }\n        } catch (error) {\n            console.error(\"Error setting up audio processing:\", error);\n        }\n    };\n    // Calculate energy specifically in human speech frequency ranges\n    const calculateSpeechEnergy = (buffer)=>{\n        let sum = 0;\n        const bufferLength = buffer.length;\n        for(let i = 0; i < bufferLength; i++){\n            sum += Math.abs(buffer[i]);\n        }\n        return sum / bufferLength;\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setUserSpeechSynthesis(window.speechSynthesis);\n        setUserLocalStorage(localStorage);\n    }, []);\n    // if selectedLanguage changes, reset call\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        endCall();\n    }, [\n        defaultIntroduction,\n        selectedLanguage\n    ]);\n    // Monitor transcript changes to detect interruptions\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (isChatbotSpeaking.current && transcript && transcript !== lastTranscriptRef.current) {\n            // Check if we're outside the cooldown period\n            const timeSinceBotStarted = Date.now() - botSpeechStartTimeRef.current;\n            if (timeSinceBotStarted > cooldownPeriodMs) {\n                // User is speaking while the bot is speaking - handle interruption\n                if (transcript.trim().length > 3) {\n                    // Validate that this isn't an echo of bot's own voice\n                    if (!isEchoOfBotSpeech(transcript)) {\n                        handleInterruption();\n                    }\n                }\n            }\n        }\n        // Store the current transcript for comparison\n        if (transcript) {\n            lastTranscriptRef.current = transcript;\n        }\n        // Reset pause timer when user speaks\n        if (transcript && transcript.trim() && pauseTimerRef.current) {\n            clearTimeout(pauseTimerRef.current);\n            pauseTimerRef.current = null;\n        }\n        // Set pause timer when user stops speaking\n        if (listening && transcript && !pauseTimerRef.current && !isChatbotSpeaking.current) {\n            pauseTimerRef.current = setTimeout(()=>{\n                // Process the transcript after pause\n                if (transcript.trim()) {\n                    handleSend(transcript);\n                    resetTranscript();\n                }\n                pauseTimerRef.current = null;\n            }, pauseThreshold * 1000);\n        }\n    }, [\n        transcript,\n        listening,\n        pauseThreshold\n    ]);\n    // Simplified echo detection\n    const isEchoOfBotSpeech = (transcriptText)=>{\n        if (!currentSpeechContentRef.current || transcriptText.length < 3) return false;\n        // Normalize strings for comparison (lowercase, remove punctuation)\n        const normalizeText = (text)=>text.toLowerCase().replace(/[.,\\/#!$%\\^&\\*;:{}=\\-_`~()]/g, \"\");\n        const normalizedTranscript = normalizeText(transcriptText);\n        const normalizedBotSpeech = normalizeText(currentSpeechContentRef.current);\n        // Check if transcript is a substring of bot speech\n        return normalizedBotSpeech.includes(normalizedTranscript);\n    };\n    // Connect/disconnect audio processor based on bot speaking state\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (speechDetectorRef.current && audioContextRef.current) {\n            if (isChatbotSpeaking.current) {\n                // Connect the processor when bot starts speaking to detect interruptions\n                try {\n                    speechDetectorRef.current.connect(audioContextRef.current.destination);\n                } catch (error) {\n                    console.error(\"Error connecting speech detector:\", error);\n                }\n            } else {\n                // Disconnect when bot stops speaking to save resources\n                try {\n                    speechDetectorRef.current.disconnect();\n                } catch (error) {\n                // Ignore disconnection errors\n                }\n            }\n        }\n    }, [\n        isWinSpeaking\n    ]);\n    const handleInterruption = ()=>{\n        if (isChatbotSpeaking.current && !isHandlingInterruption.current) {\n            isHandlingInterruption.current = true;\n            console.log(\"User interrupted - stopping bot speech\");\n            // Stop the current speech\n            if (userSpeechSynthesis && speechUtteranceRef.current) {\n                userSpeechSynthesis.cancel();\n            }\n            // Reset speaking state\n            isChatbotSpeaking.current = false;\n            setIsWinSpeaking(false);\n            currentSpeechContentRef.current = \"\";\n            // Short delay to prevent race conditions\n            setTimeout(()=>{\n                isHandlingInterruption.current = false;\n            }, 500);\n        }\n    };\n    const handleUserSpeech = (userInput)=>{\n        // Reset pause timer if exists\n        if (pauseTimerRef.current) {\n            clearTimeout(pauseTimerRef.current);\n            pauseTimerRef.current = null;\n        }\n        // Set new pause timer\n        pauseTimerRef.current = setTimeout(()=>{\n            if (userInput.trim()) {\n                handleSend(userInput);\n                resetTranscript();\n            }\n            pauseTimerRef.current = null;\n        }, pauseThreshold * 1000);\n    };\n    const chatBotSpeak = (message)=>{\n        if (!userSpeechSynthesis || !isUserCalling.current) {\n            return;\n        }\n        if (!react_speech_recognition__WEBPACK_IMPORTED_MODULE_2__[\"default\"].browserSupportsSpeechRecognition()) {\n            userSpeechSynthesis.speak(new SpeechSynthesisUtterance(t(\"Win.browserNotSupportSpeechRecognitionMessage\")));\n            return;\n        }\n        // Store speech content for echo detection\n        currentSpeechContentRef.current = message;\n        // Create and store the utterance object so we can cancel it if interrupted\n        const utterance = new SpeechSynthesisUtterance(message);\n        utterance.lang = selectedLanguage;\n        utterance.onstart = handleChatbotSpeechStart;\n        utterance.onend = handleChatbotSpeechEnd;\n        // Add properties for clear speech\n        utterance.volume = 1.0; // Full volume for clarity\n        utterance.rate = 1.0; // Normal speech rate\n        utterance.pitch = 1.0; // Normal pitch\n        speechUtteranceRef.current = utterance;\n        userSpeechSynthesis.speak(utterance);\n    };\n    const handleChatbotSpeechStart = ()=>{\n        isChatbotSpeaking.current = true;\n        setIsWinSpeaking(true);\n        // Record the time when bot started speaking for cooldown implementation\n        botSpeechStartTimeRef.current = Date.now();\n        // Reset user speaking detection\n        isUserSpeakingRef.current = false;\n        // Start or ensure recognition is running to detect interruptions\n        if (!listening) {\n            react_speech_recognition__WEBPACK_IMPORTED_MODULE_2__[\"default\"].startListening({\n                language: selectedLanguage,\n                continuous: true\n            });\n        }\n    };\n    const handleChatbotSpeechEnd = ()=>{\n        isChatbotSpeaking.current = false;\n        setIsWinSpeaking(false);\n        speechUtteranceRef.current = null;\n        currentSpeechContentRef.current = \"\";\n        isUserSpeakingRef.current = false;\n        // Keep listening for user input\n        if (isUserCalling.current && !listening) {\n            react_speech_recognition__WEBPACK_IMPORTED_MODULE_2__[\"default\"].startListening({\n                language: selectedLanguage,\n                continuous: true\n            });\n        }\n    };\n    const handleSend = async (message)=>{\n        if (!message) {\n            return;\n        }\n        const formattedMessage = {\n            message,\n            sender: \"user\"\n        };\n        const updatedMessages = [\n            ...messages,\n            formattedMessage\n        ];\n        setMessages(updatedMessages);\n        // Call from conversation ideas\n        if (!isUserCalling.current) {\n            isUserCalling.current = true;\n            setIsCalling(isUserCalling.current);\n        }\n        // If bot is speaking, stop it\n        if (isChatbotSpeaking.current) {\n            var _userSpeechSynthesis;\n            (_userSpeechSynthesis = userSpeechSynthesis) === null || _userSpeechSynthesis === void 0 ? void 0 : _userSpeechSynthesis.cancel();\n            isChatbotSpeaking.current = false;\n            setIsWinSpeaking(false);\n        }\n        const chatGPTAnswer = await (0,_callUtil__WEBPACK_IMPORTED_MODULE_5__.getChatGptAnswer)(updatedMessages);\n        setMessages([\n            ...updatedMessages,\n            {\n                message: chatGPTAnswer,\n                sender: \"ChatGPT\"\n            }\n        ]);\n        chatBotSpeak(chatGPTAnswer);\n    };\n    const userSpeak = ()=>{\n        // Start listening continuously\n        react_speech_recognition__WEBPACK_IMPORTED_MODULE_2__[\"default\"].startListening({\n            language: selectedLanguage,\n            continuous: true\n        });\n        if (transcript !== \"\") {\n            resetTranscript();\n        }\n    };\n    const userStopSpeaking = ()=>{\n        react_speech_recognition__WEBPACK_IMPORTED_MODULE_2__[\"default\"].stopListening();\n        // Process any pending transcript\n        if (transcript.trim()) {\n            handleSend(transcript);\n            resetTranscript();\n        }\n        // Clear any pending pause timer\n        if (pauseTimerRef.current) {\n            clearTimeout(pauseTimerRef.current);\n            pauseTimerRef.current = null;\n        }\n    };\n    const userCall = ()=>{\n        isUserCalling.current = true;\n        setIsCalling(isUserCalling.current);\n        if (!react_speech_recognition__WEBPACK_IMPORTED_MODULE_2__[\"default\"].browserSupportsSpeechRecognition()) {\n            setMessages([\n                ...messages,\n                {\n                    message: t(\"Win.browserNotSupportSpeechRecognitionMessage\"),\n                    sender: \"ChatGPT\"\n                }\n            ]);\n            isUserCalling.current = false;\n            setIsCalling(isUserCalling.current);\n            return;\n        }\n        const firstMessage = t(\"Win.firstMessage\");\n        const formattedMessage = {\n            message: firstMessage,\n            sender: \"assistant\"\n        };\n        const updatedMessages = [\n            ...messages,\n            formattedMessage\n        ];\n        setMessages(updatedMessages);\n        // Start listening before the bot speaks\n        react_speech_recognition__WEBPACK_IMPORTED_MODULE_2__[\"default\"].startListening({\n            language: selectedLanguage,\n            continuous: true\n        });\n        chatBotSpeak(firstMessage);\n    };\n    const updateCallHistory = ()=>{\n        if (userLocalStorage && messages.length > 1) {\n            var _userLocalStorage;\n            const storage = userLocalStorage.getItem(\"callHistory\") ? JSON.parse(userLocalStorage.getItem(\"callHistory\")) : [];\n            const newCallHistory = [\n                ...storage,\n                {\n                    messages,\n                    date: new Date().toLocaleString()\n                }\n            ];\n            (_userLocalStorage = userLocalStorage) === null || _userLocalStorage === void 0 ? void 0 : _userLocalStorage.setItem(\"callHistory\", JSON.stringify(newCallHistory));\n        }\n    };\n    const hangUp = ()=>{\n        // Clear any pending pause timer\n        if (pauseTimerRef.current) {\n            clearTimeout(pauseTimerRef.current);\n            pauseTimerRef.current = null;\n        }\n        // Disconnect audio processor if active\n        if (speechDetectorRef.current && audioContextRef.current && speechDetectorRef.current.context.state !== \"closed\") {\n            try {\n                speechDetectorRef.current.disconnect();\n            } catch (error) {\n            // Ignore errors on disconnection\n            }\n        }\n        react_speech_recognition__WEBPACK_IMPORTED_MODULE_2__[\"default\"].stopListening();\n        setMessages(defaultMessage);\n        isUserCalling.current = false;\n        setIsCalling(isUserCalling.current);\n        currentSpeechContentRef.current = \"\";\n        if (isChatbotSpeaking.current) {\n            var _userSpeechSynthesis;\n            (_userSpeechSynthesis = userSpeechSynthesis) === null || _userSpeechSynthesis === void 0 ? void 0 : _userSpeechSynthesis.cancel();\n            isChatbotSpeaking.current = false;\n            setIsWinSpeaking(false);\n            speechUtteranceRef.current = null;\n        }\n        react_speech_recognition__WEBPACK_IMPORTED_MODULE_2__[\"default\"].abortListening();\n        resetTranscript();\n    };\n    const endCall = ()=>{\n        hangUp();\n        updateCallHistory();\n    };\n    const updatePauseThreshold = (seconds)=>{\n        if (seconds >= 0.5 && seconds <= 5) {\n            setPauseThreshold(seconds);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(CallContext.Provider, {\n        value: {\n            userCall,\n            userSpeak,\n            userStopSpeaking,\n            listening,\n            isCalling,\n            endCall,\n            handleSend,\n            messages,\n            isChatbotSpeaking: isWinSpeaking,\n            pauseThreshold,\n            setPauseThreshold: updatePauseThreshold\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"D:\\\\react-voice-chatbot\\\\react-voice-chatbot\\\\components\\\\CallManager.tsx\",\n        lineNumber: 541,\n        columnNumber: 5\n    }, undefined);\n};\n_s(CallManager, \"iYZflVNu4+tAwooFhR8JkfGdnHU=\", false, function() {\n    return [\n        react_speech_recognition__WEBPACK_IMPORTED_MODULE_2__.useSpeechRecognition,\n        next_i18next__WEBPACK_IMPORTED_MODULE_3__.useTranslation,\n        _LanguageManager__WEBPACK_IMPORTED_MODULE_4__.useLanguage\n    ];\n});\n_c = CallManager;\nconst useCallManager = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(CallContext);\n    if (context === undefined) {\n        throw new Error(\"useCallManager must be used within a CallManager\");\n    }\n    return context;\n};\n_s1(useCallManager, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n/* harmony default export */ __webpack_exports__[\"default\"] = (CallManager);\nvar _c;\n$RefreshReg$(_c, \"CallManager\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RztZQUNBdEQ7WUFDQXJDLG1CQUFtQm9CO1lBQ25CaEI7WUFDQUMsbUJBQW1Cc0k7UUFDckI7a0JBRUM3STs7Ozs7O0FBR1A7R0E5Z0JNRDs7UUF3QytDTiwwRUFBb0JBO1FBR3pEQyx3REFBY0E7UUFHQ0MseURBQVdBOzs7S0E5Q3BDSTtBQStnQkMsTUFBTWlKLGlCQUFpQjs7SUFDNUIsTUFBTUwsVUFBVXZKLGlEQUFVQSxDQUFDUztJQUMzQixJQUFJOEksWUFBWTdJLFdBQVc7UUFDekIsTUFBTSxJQUFJbUosTUFBTTtJQUNsQjtJQUNBLE9BQU9OO0FBQ1QsRUFBRTtJQU5XSztBQU9iLCtEQUFlakosV0FBV0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0NhbGxNYW5hZ2VyLnRzeD9mMjJhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZVN0YXRlLCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBTcGVlY2hSZWNvZ25pdGlvbiwgeyB1c2VTcGVlY2hSZWNvZ25pdGlvbiB9IGZyb20gJ3JlYWN0LXNwZWVjaC1yZWNvZ25pdGlvbic7XHJcbmltcG9ydCB7IHVzZVRyYW5zbGF0aW9uIH0gZnJvbSAnbmV4dC1pMThuZXh0JztcclxuaW1wb3J0IHsgdXNlTGFuZ3VhZ2UgfSBmcm9tICcuL0xhbmd1YWdlTWFuYWdlcic7XHJcbmltcG9ydCB7IGdldENoYXRHcHRBbnN3ZXIgfSBmcm9tICcuL2NhbGxVdGlsJztcclxuaW1wb3J0IHsgQ2FsbEhpc3RvcnlUeXBlIH0gZnJvbSAnLi9DYWxsSGlzdG9yeSc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE1lc3NhZ2VUeXBlIHtcclxuICBtZXNzYWdlOiBzdHJpbmc7XHJcbiAgc2VuZGVyOiBzdHJpbmc7XHJcbn1cclxuXHJcbmludGVyZmFjZSBDYWxsQ29udGV4dFR5cGUge1xyXG4gIHVzZXJDYWxsOiAoKSA9PiB2b2lkO1xyXG4gIHVzZXJTcGVhazogKCkgPT4gdm9pZDtcclxuICB1c2VyU3RvcFNwZWFraW5nOiAoKSA9PiB2b2lkO1xyXG4gIGxpc3RlbmluZzogYm9vbGVhbjtcclxuICBpc0NhbGxpbmc6IGJvb2xlYW47XHJcbiAgZW5kQ2FsbDogKCkgPT4gdm9pZDtcclxuICBoYW5kbGVTZW5kOiAobWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkO1xyXG4gIG1lc3NhZ2VzOiBNZXNzYWdlVHlwZVtdO1xyXG4gIGlzQ2hhdGJvdFNwZWFraW5nOiBib29sZWFuO1xyXG4gIHBhdXNlVGhyZXNob2xkOiBudW1iZXI7XHJcbiAgc2V0UGF1c2VUaHJlc2hvbGQ6IChzZWNvbmRzOiBudW1iZXIpID0+IHZvaWQ7XHJcbn1cclxuXHJcbmNvbnN0IENhbGxDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxDYWxsQ29udGV4dFR5cGUgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XHJcblxyXG50eXBlIENhbGxNYW5hZ2VyUHJvcHMgPSB7XHJcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZTtcclxufTtcclxuXHJcbmNvbnN0IENhbGxNYW5hZ2VyOiBSZWFjdC5GQzxDYWxsTWFuYWdlclByb3BzPiA9ICh7IGNoaWxkcmVuIH0pID0+IHtcclxuICBjb25zdCBpc1VzZXJDYWxsaW5nID0gdXNlUmVmKGZhbHNlKTtcclxuICBjb25zdCBpc0NoYXRib3RTcGVha2luZyA9IHVzZVJlZihmYWxzZSk7XHJcbiAgY29uc3Qgc3BlZWNoVXR0ZXJhbmNlUmVmID0gdXNlUmVmPFNwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZSB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IHBhdXNlVGltZXJSZWYgPSB1c2VSZWY8Tm9kZUpTLlRpbWVvdXQgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBsYXN0VHJhbnNjcmlwdFJlZiA9IHVzZVJlZjxzdHJpbmc+KCcnKTtcclxuICBjb25zdCBbcGF1c2VUaHJlc2hvbGQsIHNldFBhdXNlVGhyZXNob2xkXSA9IHVzZVN0YXRlPG51bWJlcj4oMik7IC8vIERlZmF1bHQgMiBzZWNvbmRzXHJcblxyXG4gIC8vIFRyYWNrIGlmIHdlJ3JlIGhhbmRsaW5nIGFuIGludGVycnVwdGlvblxyXG4gIGNvbnN0IGlzSGFuZGxpbmdJbnRlcnJ1cHRpb24gPSB1c2VSZWYoZmFsc2UpO1xyXG4gIFxyXG4gIC8vIEtlZXAgdHJhY2sgb2Ygd2hlbiBib3Qgc3RhcnRlZCBzcGVha2luZyB0byBpbXBsZW1lbnQgY29vbGRvd24gcGVyaW9kXHJcbiAgY29uc3QgYm90U3BlZWNoU3RhcnRUaW1lUmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcbiAgY29uc3QgY29vbGRvd25QZXJpb2RNcyA9IDcwMDsgLy8gQ29vbGRvd24gYWZ0ZXIgYm90IHN0YXJ0cyBzcGVha2luZ1xyXG4gIFxyXG4gIC8vIFJlZmVyZW5jZSB0byBBdWRpb0NvbnRleHQgYW5kIG5vZGVzIGZvciBlY2hvIGNhbmNlbGxhdGlvblxyXG4gIGNvbnN0IGF1ZGlvQ29udGV4dFJlZiA9IHVzZVJlZjxBdWRpb0NvbnRleHQgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBzcGVlY2hEZXRlY3RvclJlZiA9IHVzZVJlZjxTY3JpcHRQcm9jZXNzb3JOb2RlIHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgaXNVc2VyU3BlYWtpbmdSZWYgPSB1c2VSZWY8Ym9vbGVhbj4oZmFsc2UpO1xyXG4gIFxyXG4gIC8vIEVuZXJneSB0aHJlc2hvbGQgZm9yIGRpc3Rpbmd1aXNoaW5nIGJldHdlZW4gdXNlciBhbmQgYm90IHNwZWVjaFxyXG4gIGNvbnN0IGVuZXJneVRocmVzaG9sZFJlZiA9IHVzZVJlZjxudW1iZXI+KDAuMTIpO1xyXG4gIFxyXG4gIC8vIEFkZCBhIHJlZmVyZW5jZSBmb3IgdGhlIGN1cnJlbnQgc3BlZWNoIGNvbnRlbnQgdG8gaGVscCB3aXRoIGZpbmdlcnByaW50aW5nXHJcbiAgY29uc3QgY3VycmVudFNwZWVjaENvbnRlbnRSZWYgPSB1c2VSZWY8c3RyaW5nPignJyk7XHJcblxyXG4gIGNvbnN0IGNvbW1hbmRzID0gW1xyXG4gICAge1xyXG4gICAgICBjb21tYW5kOiBbJyonXSxcclxuICAgICAgY2FsbGJhY2s6IChjb21tYW5kOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAvLyBPbmx5IHByb2Nlc3MgY29tbWFuZCB3aGVuIGEgc2lnbmlmaWNhbnQgY2hhbmdlIG9jY3Vyc1xyXG4gICAgICAgIGlmIChjb21tYW5kLnRyaW0oKSAmJiBjb21tYW5kICE9PSBsYXN0VHJhbnNjcmlwdFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICBoYW5kbGVVc2VyU3BlZWNoKGNvbW1hbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgIH0sXHJcbiAgXTtcclxuXHJcbiAgY29uc3QgW2lzV2luU3BlYWtpbmcsIHNldElzV2luU3BlYWtpbmddID0gdXNlU3RhdGUoaXNDaGF0Ym90U3BlYWtpbmcuY3VycmVudCk7XHJcbiAgY29uc3QgW2lzQ2FsbGluZywgc2V0SXNDYWxsaW5nXSA9IHVzZVN0YXRlKGlzVXNlckNhbGxpbmcuY3VycmVudCk7XHJcbiAgY29uc3QgeyB0cmFuc2NyaXB0LCByZXNldFRyYW5zY3JpcHQsIGxpc3RlbmluZyB9ID0gdXNlU3BlZWNoUmVjb2duaXRpb24oe1xyXG4gICAgY29tbWFuZHMsXHJcbiAgfSk7XHJcbiAgY29uc3QgeyB0IH0gPSB1c2VUcmFuc2xhdGlvbigpO1xyXG4gIGNvbnN0IFt1c2VyU3BlZWNoU3ludGhlc2lzLCBzZXRVc2VyU3BlZWNoU3ludGhlc2lzXSA9IHVzZVN0YXRlPFNwZWVjaFN5bnRoZXNpcz4oKTtcclxuICBjb25zdCBbdXNlckxvY2FsU3RvcmFnZSwgc2V0VXNlckxvY2FsU3RvcmFnZV0gPSB1c2VTdGF0ZTxTdG9yYWdlPigpO1xyXG4gIGNvbnN0IHsgc2VsZWN0ZWRMYW5ndWFnZSB9ID0gdXNlTGFuZ3VhZ2UoKTtcclxuICBjb25zdCBkZWZhdWx0SW50cm9kdWN0aW9uID0gdCgnV2luLmludHJvZHVjdGlvbicpO1xyXG4gIGNvbnN0IGRlZmF1bHRNZXNzYWdlID0gW1xyXG4gICAge1xyXG4gICAgICBtZXNzYWdlOiBkZWZhdWx0SW50cm9kdWN0aW9uLFxyXG4gICAgICBzZW5kZXI6ICdDaGF0R1BUJyxcclxuICAgIH0sXHJcbiAgXTtcclxuICBjb25zdCBbbWVzc2FnZXMsIHNldE1lc3NhZ2VzXSA9IHVzZVN0YXRlPE1lc3NhZ2VUeXBlW10+KGRlZmF1bHRNZXNzYWdlKTtcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSBhdWRpbyBjb250ZXh0IHdoZW4gY29tcG9uZW50IG1vdW50c1xyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBBdWRpb0NvbnRleHQgPSB3aW5kb3cuQXVkaW9Db250ZXh0IHx8ICh3aW5kb3cgYXMgYW55KS53ZWJraXRBdWRpb0NvbnRleHQ7XHJcbiAgICAgICAgYXVkaW9Db250ZXh0UmVmLmN1cnJlbnQgPSBuZXcgQXVkaW9Db250ZXh0KCk7XHJcbiAgICAgICAgc2V0dXBBdWRpb1Byb2Nlc3NpbmcoKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW5pdGlhbGl6aW5nIEF1ZGlvQ29udGV4dDpcIiwgZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIC8vIENsZWFuIHVwIGF1ZGlvIGNvbnRleHQgd2hlbiBjb21wb25lbnQgdW5tb3VudHNcclxuICAgICAgaWYgKGF1ZGlvQ29udGV4dFJlZi5jdXJyZW50ICYmIGF1ZGlvQ29udGV4dFJlZi5jdXJyZW50LnN0YXRlICE9PSAnY2xvc2VkJykge1xyXG4gICAgICAgIGF1ZGlvQ29udGV4dFJlZi5jdXJyZW50LmNsb3NlKCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSwgW10pO1xyXG5cclxuICAvLyBTZXQgdXAgYXVkaW8gcHJvY2Vzc2luZyBmb3Igc3BlZWNoIGRldGVjdGlvbiB3aXRoIGVjaG8gY2FuY2VsbGF0aW9uXHJcbiAgY29uc3Qgc2V0dXBBdWRpb1Byb2Nlc3NpbmcgPSBhc3luYyAoKSA9PiB7XHJcbiAgICBpZiAoIWF1ZGlvQ29udGV4dFJlZi5jdXJyZW50KSByZXR1cm47XHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIEdldCB1c2VyIG1pY3JvcGhvbmUgYWNjZXNzXHJcbiAgICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHsgXHJcbiAgICAgICAgYXVkaW86IHsgXHJcbiAgICAgICAgICBlY2hvQ2FuY2VsbGF0aW9uOiB0cnVlLCAgLy8gRW5hYmxlIGJyb3dzZXIncyBidWlsdC1pbiBlY2hvIGNhbmNlbGxhdGlvblxyXG4gICAgICAgICAgbm9pc2VTdXBwcmVzc2lvbjogdHJ1ZSwgIC8vIEVuYWJsZSBub2lzZSBzdXBwcmVzc2lvblxyXG4gICAgICAgICAgYXV0b0dhaW5Db250cm9sOiB0cnVlICAgIC8vIEVuYWJsZSBhdXRvbWF0aWMgZ2FpbiBjb250cm9sXHJcbiAgICAgICAgfSBcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBDcmVhdGUgYXVkaW8gc291cmNlIGZyb20gbWljcm9waG9uZVxyXG4gICAgICBjb25zdCBtaWNTb3VyY2UgPSBhdWRpb0NvbnRleHRSZWYuY3VycmVudC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShzdHJlYW0pO1xyXG4gICAgICBcclxuICAgICAgLy8gQ3JlYXRlIHNjcmlwdCBwcm9jZXNzb3IgZm9yIGFuYWx5emluZyBhdWRpb1xyXG4gICAgICBjb25zdCBwcm9jZXNzb3IgPSBhdWRpb0NvbnRleHRSZWYuY3VycmVudC5jcmVhdGVTY3JpcHRQcm9jZXNzb3IoNDA5NiwgMSwgMSk7XHJcbiAgICAgIHNwZWVjaERldGVjdG9yUmVmLmN1cnJlbnQgPSBwcm9jZXNzb3I7XHJcbiAgICAgIFxyXG4gICAgICBtaWNTb3VyY2UuY29ubmVjdChwcm9jZXNzb3IpO1xyXG4gICAgICBcclxuICAgICAgLy8gUHJvY2VzcyBhdWRpbyBkYXRhIHRvIGRldGVjdCBzcGVlY2ggd2l0aCBlbmhhbmNlZCBlY2hvIGNhbmNlbGxhdGlvblxyXG4gICAgICBwcm9jZXNzb3Iub25hdWRpb3Byb2Nlc3MgPSAoZSkgPT4ge1xyXG4gICAgICAgIGlmIChpc0NoYXRib3RTcGVha2luZy5jdXJyZW50KSB7XHJcbiAgICAgICAgICAvLyBTa2lwIHByb2Nlc3NpbmcgZHVyaW5nIHRoZSBjb29sZG93biBwZXJpb2RcclxuICAgICAgICAgIGNvbnN0IHRpbWVTaW5jZUJvdFN0YXJ0ZWQgPSBEYXRlLm5vdygpIC0gYm90U3BlZWNoU3RhcnRUaW1lUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgICBpZiAodGltZVNpbmNlQm90U3RhcnRlZCA8IGNvb2xkb3duUGVyaW9kTXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjb25zdCBpbnB1dCA9IGUuaW5wdXRCdWZmZXIuZ2V0Q2hhbm5lbERhdGEoMCk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBhdWRpbyBlbmVyZ3kgaW4gaHVtYW4gc3BlZWNoIGZyZXF1ZW5jeSByYW5nZVxyXG4gICAgICAgICAgY29uc3Qgc3BlZWNoRW5lcmd5ID0gY2FsY3VsYXRlU3BlZWNoRW5lcmd5KGlucHV0KTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gSWYgZW5lcmd5IGV4Y2VlZHMgdGhyZXNob2xkLCBsaWtlbHkgdXNlciBpcyBzcGVha2luZ1xyXG4gICAgICAgICAgaWYgKHNwZWVjaEVuZXJneSA+IGVuZXJneVRocmVzaG9sZFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGlmICghaXNVc2VyU3BlYWtpbmdSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICAgIGlzVXNlclNwZWFraW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIC8vIEFkZCBkZWJvdW5jZSB0byBwcmV2ZW50IGZhbHNlIHRyaWdnZXJzXHJcbiAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNVc2VyU3BlYWtpbmdSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVzZXIgaW50ZXJydXB0ZWQgLSBodW1hbiBzcGVlY2ggZGV0ZWN0ZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgIGhhbmRsZUludGVycnVwdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0sIDE4MCk7IC8vIFdhaXQgMTgwbXMgdG8gY29uZmlybSBjb25zaXN0ZW50IHNwZWVjaFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpc1VzZXJTcGVha2luZ1JlZi5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgLy8gQ29ubmVjdCBidXQgd2l0aCBnYWluIG5vZGUgdG8gY29udHJvbCB2b2x1bWUgZ29pbmcgdG8gb3V0cHV0XHJcbiAgICAgIGNvbnN0IGdhaW5Ob2RlID0gYXVkaW9Db250ZXh0UmVmLmN1cnJlbnQuY3JlYXRlR2FpbigpO1xyXG4gICAgICBnYWluTm9kZS5nYWluLnZhbHVlID0gMDsgLy8gU2V0IHRvIDAgdG8gcHJldmVudCBhdWRpbyBmZWVkYmFjayB0byBzcGVha2Vyc1xyXG4gICAgICBcclxuICAgICAgcHJvY2Vzc29yLmNvbm5lY3QoZ2Fpbk5vZGUpO1xyXG4gICAgICBnYWluTm9kZS5jb25uZWN0KGF1ZGlvQ29udGV4dFJlZi5jdXJyZW50LmRlc3RpbmF0aW9uKTtcclxuICAgICAgXHJcbiAgICAgIC8vIERpc2Nvbm5lY3Qgd2hlbiBub3QgbmVlZGVkXHJcbiAgICAgIGlmICghaXNDaGF0Ym90U3BlYWtpbmcuY3VycmVudCkge1xyXG4gICAgICAgIHByb2Nlc3Nvci5kaXNjb25uZWN0KCk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc2V0dGluZyB1cCBhdWRpbyBwcm9jZXNzaW5nOlwiLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfTtcclxuICBcclxuICAvLyBDYWxjdWxhdGUgZW5lcmd5IHNwZWNpZmljYWxseSBpbiBodW1hbiBzcGVlY2ggZnJlcXVlbmN5IHJhbmdlc1xyXG4gIGNvbnN0IGNhbGN1bGF0ZVNwZWVjaEVuZXJneSA9IChidWZmZXI6IEZsb2F0MzJBcnJheSk6IG51bWJlciA9PiB7XHJcbiAgICBsZXQgc3VtID0gMDtcclxuICAgIGNvbnN0IGJ1ZmZlckxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XHJcbiAgICBcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyTGVuZ3RoOyBpKyspIHtcclxuICAgICAgc3VtICs9IE1hdGguYWJzKGJ1ZmZlcltpXSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBzdW0gLyBidWZmZXJMZW5ndGg7XHJcbiAgfTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIHNldFVzZXJTcGVlY2hTeW50aGVzaXMod2luZG93LnNwZWVjaFN5bnRoZXNpcyk7XHJcbiAgICBzZXRVc2VyTG9jYWxTdG9yYWdlKGxvY2FsU3RvcmFnZSk7XHJcbiAgfSwgW10pO1xyXG5cclxuICAvLyBpZiBzZWxlY3RlZExhbmd1YWdlIGNoYW5nZXMsIHJlc2V0IGNhbGxcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgZW5kQ2FsbCgpO1xyXG4gIH0sIFtkZWZhdWx0SW50cm9kdWN0aW9uLCBzZWxlY3RlZExhbmd1YWdlXSk7XHJcblxyXG4gIC8vIE1vbml0b3IgdHJhbnNjcmlwdCBjaGFuZ2VzIHRvIGRldGVjdCBpbnRlcnJ1cHRpb25zXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmIChpc0NoYXRib3RTcGVha2luZy5jdXJyZW50ICYmIHRyYW5zY3JpcHQgJiYgdHJhbnNjcmlwdCAhPT0gbGFzdFRyYW5zY3JpcHRSZWYuY3VycmVudCkge1xyXG4gICAgICAvLyBDaGVjayBpZiB3ZSdyZSBvdXRzaWRlIHRoZSBjb29sZG93biBwZXJpb2RcclxuICAgICAgY29uc3QgdGltZVNpbmNlQm90U3RhcnRlZCA9IERhdGUubm93KCkgLSBib3RTcGVlY2hTdGFydFRpbWVSZWYuY3VycmVudDtcclxuICAgICAgaWYgKHRpbWVTaW5jZUJvdFN0YXJ0ZWQgPiBjb29sZG93blBlcmlvZE1zKSB7XHJcbiAgICAgICAgLy8gVXNlciBpcyBzcGVha2luZyB3aGlsZSB0aGUgYm90IGlzIHNwZWFraW5nIC0gaGFuZGxlIGludGVycnVwdGlvblxyXG4gICAgICAgIGlmICh0cmFuc2NyaXB0LnRyaW0oKS5sZW5ndGggPiAzKSB7IC8vIEF2b2lkIHRyaWdnZXJpbmcgb24gc21hbGwgbm9pc2VzXHJcbiAgICAgICAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoaXMgaXNuJ3QgYW4gZWNobyBvZiBib3QncyBvd24gdm9pY2VcclxuICAgICAgICAgIGlmICghaXNFY2hvT2ZCb3RTcGVlY2godHJhbnNjcmlwdCkpIHtcclxuICAgICAgICAgICAgaGFuZGxlSW50ZXJydXB0aW9uKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFN0b3JlIHRoZSBjdXJyZW50IHRyYW5zY3JpcHQgZm9yIGNvbXBhcmlzb25cclxuICAgIGlmICh0cmFuc2NyaXB0KSB7XHJcbiAgICAgIGxhc3RUcmFuc2NyaXB0UmVmLmN1cnJlbnQgPSB0cmFuc2NyaXB0O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBSZXNldCBwYXVzZSB0aW1lciB3aGVuIHVzZXIgc3BlYWtzXHJcbiAgICBpZiAodHJhbnNjcmlwdCAmJiB0cmFuc2NyaXB0LnRyaW0oKSAmJiBwYXVzZVRpbWVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgY2xlYXJUaW1lb3V0KHBhdXNlVGltZXJSZWYuY3VycmVudCk7XHJcbiAgICAgIHBhdXNlVGltZXJSZWYuY3VycmVudCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFNldCBwYXVzZSB0aW1lciB3aGVuIHVzZXIgc3RvcHMgc3BlYWtpbmdcclxuICAgIGlmIChsaXN0ZW5pbmcgJiYgdHJhbnNjcmlwdCAmJiAhcGF1c2VUaW1lclJlZi5jdXJyZW50ICYmICFpc0NoYXRib3RTcGVha2luZy5jdXJyZW50KSB7XHJcbiAgICAgIHBhdXNlVGltZXJSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIHRyYW5zY3JpcHQgYWZ0ZXIgcGF1c2VcclxuICAgICAgICBpZiAodHJhbnNjcmlwdC50cmltKCkpIHtcclxuICAgICAgICAgIGhhbmRsZVNlbmQodHJhbnNjcmlwdCk7XHJcbiAgICAgICAgICByZXNldFRyYW5zY3JpcHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGF1c2VUaW1lclJlZi5jdXJyZW50ID0gbnVsbDtcclxuICAgICAgfSwgcGF1c2VUaHJlc2hvbGQgKiAxMDAwKTtcclxuICAgIH1cclxuICB9LCBbdHJhbnNjcmlwdCwgbGlzdGVuaW5nLCBwYXVzZVRocmVzaG9sZF0pO1xyXG5cclxuICAvLyBTaW1wbGlmaWVkIGVjaG8gZGV0ZWN0aW9uXHJcbiAgY29uc3QgaXNFY2hvT2ZCb3RTcGVlY2ggPSAodHJhbnNjcmlwdFRleHQ6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xyXG4gICAgaWYgKCFjdXJyZW50U3BlZWNoQ29udGVudFJlZi5jdXJyZW50IHx8IHRyYW5zY3JpcHRUZXh0Lmxlbmd0aCA8IDMpIHJldHVybiBmYWxzZTtcclxuICAgIFxyXG4gICAgLy8gTm9ybWFsaXplIHN0cmluZ3MgZm9yIGNvbXBhcmlzb24gKGxvd2VyY2FzZSwgcmVtb3ZlIHB1bmN0dWF0aW9uKVxyXG4gICAgY29uc3Qgbm9ybWFsaXplVGV4dCA9ICh0ZXh0OiBzdHJpbmcpID0+IHRleHQudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bLixcXC8jISQlXFxeJlxcKjs6e309XFwtX2B+KCldL2csIFwiXCIpO1xyXG4gICAgXHJcbiAgICBjb25zdCBub3JtYWxpemVkVHJhbnNjcmlwdCA9IG5vcm1hbGl6ZVRleHQodHJhbnNjcmlwdFRleHQpO1xyXG4gICAgY29uc3Qgbm9ybWFsaXplZEJvdFNwZWVjaCA9IG5vcm1hbGl6ZVRleHQoY3VycmVudFNwZWVjaENvbnRlbnRSZWYuY3VycmVudCk7XHJcbiAgICBcclxuICAgIC8vIENoZWNrIGlmIHRyYW5zY3JpcHQgaXMgYSBzdWJzdHJpbmcgb2YgYm90IHNwZWVjaFxyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRCb3RTcGVlY2guaW5jbHVkZXMobm9ybWFsaXplZFRyYW5zY3JpcHQpO1xyXG4gIH07XHJcblxyXG4gIC8vIENvbm5lY3QvZGlzY29ubmVjdCBhdWRpbyBwcm9jZXNzb3IgYmFzZWQgb24gYm90IHNwZWFraW5nIHN0YXRlXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmIChzcGVlY2hEZXRlY3RvclJlZi5jdXJyZW50ICYmIGF1ZGlvQ29udGV4dFJlZi5jdXJyZW50KSB7XHJcbiAgICAgIGlmIChpc0NoYXRib3RTcGVha2luZy5jdXJyZW50KSB7XHJcbiAgICAgICAgLy8gQ29ubmVjdCB0aGUgcHJvY2Vzc29yIHdoZW4gYm90IHN0YXJ0cyBzcGVha2luZyB0byBkZXRlY3QgaW50ZXJydXB0aW9uc1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBzcGVlY2hEZXRlY3RvclJlZi5jdXJyZW50LmNvbm5lY3QoYXVkaW9Db250ZXh0UmVmLmN1cnJlbnQuZGVzdGluYXRpb24pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY29ubmVjdGluZyBzcGVlY2ggZGV0ZWN0b3I6XCIsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gRGlzY29ubmVjdCB3aGVuIGJvdCBzdG9wcyBzcGVha2luZyB0byBzYXZlIHJlc291cmNlc1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBzcGVlY2hEZXRlY3RvclJlZi5jdXJyZW50LmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgLy8gSWdub3JlIGRpc2Nvbm5lY3Rpb24gZXJyb3JzXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwgW2lzV2luU3BlYWtpbmddKTtcclxuXHJcbiAgY29uc3QgaGFuZGxlSW50ZXJydXB0aW9uID0gKCkgPT4ge1xyXG4gICAgaWYgKGlzQ2hhdGJvdFNwZWFraW5nLmN1cnJlbnQgJiYgIWlzSGFuZGxpbmdJbnRlcnJ1cHRpb24uY3VycmVudCkge1xyXG4gICAgICBpc0hhbmRsaW5nSW50ZXJydXB0aW9uLmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgICBjb25zb2xlLmxvZyhcIlVzZXIgaW50ZXJydXB0ZWQgLSBzdG9wcGluZyBib3Qgc3BlZWNoXCIpO1xyXG4gICAgICBcclxuICAgICAgLy8gU3RvcCB0aGUgY3VycmVudCBzcGVlY2hcclxuICAgICAgaWYgKHVzZXJTcGVlY2hTeW50aGVzaXMgJiYgc3BlZWNoVXR0ZXJhbmNlUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICB1c2VyU3BlZWNoU3ludGhlc2lzLmNhbmNlbCgpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBSZXNldCBzcGVha2luZyBzdGF0ZVxyXG4gICAgICBpc0NoYXRib3RTcGVha2luZy5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgIHNldElzV2luU3BlYWtpbmcoZmFsc2UpO1xyXG4gICAgICBjdXJyZW50U3BlZWNoQ29udGVudFJlZi5jdXJyZW50ID0gJyc7XHJcbiAgICAgIFxyXG4gICAgICAvLyBTaG9ydCBkZWxheSB0byBwcmV2ZW50IHJhY2UgY29uZGl0aW9uc1xyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBpc0hhbmRsaW5nSW50ZXJydXB0aW9uLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgfSwgNTAwKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBoYW5kbGVVc2VyU3BlZWNoID0gKHVzZXJJbnB1dDogc3RyaW5nKSA9PiB7XHJcbiAgICAvLyBSZXNldCBwYXVzZSB0aW1lciBpZiBleGlzdHNcclxuICAgIGlmIChwYXVzZVRpbWVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgY2xlYXJUaW1lb3V0KHBhdXNlVGltZXJSZWYuY3VycmVudCk7XHJcbiAgICAgIHBhdXNlVGltZXJSZWYuY3VycmVudCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFNldCBuZXcgcGF1c2UgdGltZXJcclxuICAgIHBhdXNlVGltZXJSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBpZiAodXNlcklucHV0LnRyaW0oKSkge1xyXG4gICAgICAgIGhhbmRsZVNlbmQodXNlcklucHV0KTtcclxuICAgICAgICByZXNldFRyYW5zY3JpcHQoKTtcclxuICAgICAgfVxyXG4gICAgICBwYXVzZVRpbWVyUmVmLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgfSwgcGF1c2VUaHJlc2hvbGQgKiAxMDAwKTtcclxuICB9O1xyXG5cclxuICBjb25zdCBjaGF0Qm90U3BlYWsgPSAobWVzc2FnZTogc3RyaW5nKSA9PiB7XHJcbiAgICBpZiAoIXVzZXJTcGVlY2hTeW50aGVzaXMgfHwgIWlzVXNlckNhbGxpbmcuY3VycmVudCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFTcGVlY2hSZWNvZ25pdGlvbi5icm93c2VyU3VwcG9ydHNTcGVlY2hSZWNvZ25pdGlvbigpKSB7XHJcbiAgICAgIHVzZXJTcGVlY2hTeW50aGVzaXMuc3BlYWsoXHJcbiAgICAgICAgbmV3IFNwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZSh0KCdXaW4uYnJvd3Nlck5vdFN1cHBvcnRTcGVlY2hSZWNvZ25pdGlvbk1lc3NhZ2UnKSlcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBTdG9yZSBzcGVlY2ggY29udGVudCBmb3IgZWNobyBkZXRlY3Rpb25cclxuICAgIGN1cnJlbnRTcGVlY2hDb250ZW50UmVmLmN1cnJlbnQgPSBtZXNzYWdlO1xyXG4gICAgXHJcbiAgICAvLyBDcmVhdGUgYW5kIHN0b3JlIHRoZSB1dHRlcmFuY2Ugb2JqZWN0IHNvIHdlIGNhbiBjYW5jZWwgaXQgaWYgaW50ZXJydXB0ZWRcclxuICAgIGNvbnN0IHV0dGVyYW5jZSA9IG5ldyBTcGVlY2hTeW50aGVzaXNVdHRlcmFuY2UobWVzc2FnZSk7XHJcbiAgICB1dHRlcmFuY2UubGFuZyA9IHNlbGVjdGVkTGFuZ3VhZ2U7XHJcbiAgICB1dHRlcmFuY2Uub25zdGFydCA9IGhhbmRsZUNoYXRib3RTcGVlY2hTdGFydDtcclxuICAgIHV0dGVyYW5jZS5vbmVuZCA9IGhhbmRsZUNoYXRib3RTcGVlY2hFbmQ7XHJcbiAgICBcclxuICAgIC8vIEFkZCBwcm9wZXJ0aWVzIGZvciBjbGVhciBzcGVlY2hcclxuICAgIHV0dGVyYW5jZS52b2x1bWUgPSAxLjA7IC8vIEZ1bGwgdm9sdW1lIGZvciBjbGFyaXR5XHJcbiAgICB1dHRlcmFuY2UucmF0ZSA9IDEuMDsgICAvLyBOb3JtYWwgc3BlZWNoIHJhdGVcclxuICAgIHV0dGVyYW5jZS5waXRjaCA9IDEuMDsgIC8vIE5vcm1hbCBwaXRjaFxyXG4gICAgXHJcbiAgICBzcGVlY2hVdHRlcmFuY2VSZWYuY3VycmVudCA9IHV0dGVyYW5jZTtcclxuICAgIFxyXG4gICAgdXNlclNwZWVjaFN5bnRoZXNpcy5zcGVhayh1dHRlcmFuY2UpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhhbmRsZUNoYXRib3RTcGVlY2hTdGFydCA9ICgpID0+IHtcclxuICAgIGlzQ2hhdGJvdFNwZWFraW5nLmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgc2V0SXNXaW5TcGVha2luZyh0cnVlKTtcclxuICAgIFxyXG4gICAgLy8gUmVjb3JkIHRoZSB0aW1lIHdoZW4gYm90IHN0YXJ0ZWQgc3BlYWtpbmcgZm9yIGNvb2xkb3duIGltcGxlbWVudGF0aW9uXHJcbiAgICBib3RTcGVlY2hTdGFydFRpbWVSZWYuY3VycmVudCA9IERhdGUubm93KCk7XHJcbiAgICBcclxuICAgIC8vIFJlc2V0IHVzZXIgc3BlYWtpbmcgZGV0ZWN0aW9uXHJcbiAgICBpc1VzZXJTcGVha2luZ1JlZi5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICBcclxuICAgIC8vIFN0YXJ0IG9yIGVuc3VyZSByZWNvZ25pdGlvbiBpcyBydW5uaW5nIHRvIGRldGVjdCBpbnRlcnJ1cHRpb25zXHJcbiAgICBpZiAoIWxpc3RlbmluZykge1xyXG4gICAgICBTcGVlY2hSZWNvZ25pdGlvbi5zdGFydExpc3RlbmluZyh7IFxyXG4gICAgICAgIGxhbmd1YWdlOiBzZWxlY3RlZExhbmd1YWdlLFxyXG4gICAgICAgIGNvbnRpbnVvdXM6IHRydWUgXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhhbmRsZUNoYXRib3RTcGVlY2hFbmQgPSAoKSA9PiB7XHJcbiAgICBpc0NoYXRib3RTcGVha2luZy5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICBzZXRJc1dpblNwZWFraW5nKGZhbHNlKTtcclxuICAgIHNwZWVjaFV0dGVyYW5jZVJlZi5jdXJyZW50ID0gbnVsbDtcclxuICAgIGN1cnJlbnRTcGVlY2hDb250ZW50UmVmLmN1cnJlbnQgPSAnJztcclxuICAgIGlzVXNlclNwZWFraW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgIFxyXG4gICAgLy8gS2VlcCBsaXN0ZW5pbmcgZm9yIHVzZXIgaW5wdXRcclxuICAgIGlmIChpc1VzZXJDYWxsaW5nLmN1cnJlbnQgJiYgIWxpc3RlbmluZykge1xyXG4gICAgICBTcGVlY2hSZWNvZ25pdGlvbi5zdGFydExpc3RlbmluZyh7IFxyXG4gICAgICAgIGxhbmd1YWdlOiBzZWxlY3RlZExhbmd1YWdlLFxyXG4gICAgICAgIGNvbnRpbnVvdXM6IHRydWUgXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhhbmRsZVNlbmQgPSBhc3luYyAobWVzc2FnZTogc3RyaW5nKSA9PiB7XHJcbiAgICBpZiAoIW1lc3NhZ2UpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZm9ybWF0dGVkTWVzc2FnZSA9IHtcclxuICAgICAgbWVzc2FnZSxcclxuICAgICAgc2VuZGVyOiAndXNlcicsXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IHVwZGF0ZWRNZXNzYWdlcyA9IFsuLi5tZXNzYWdlcywgZm9ybWF0dGVkTWVzc2FnZV07XHJcblxyXG4gICAgc2V0TWVzc2FnZXModXBkYXRlZE1lc3NhZ2VzKTtcclxuXHJcbiAgICAvLyBDYWxsIGZyb20gY29udmVyc2F0aW9uIGlkZWFzXHJcbiAgICBpZiAoIWlzVXNlckNhbGxpbmcuY3VycmVudCkge1xyXG4gICAgICBpc1VzZXJDYWxsaW5nLmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgICBzZXRJc0NhbGxpbmcoaXNVc2VyQ2FsbGluZy5jdXJyZW50KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gSWYgYm90IGlzIHNwZWFraW5nLCBzdG9wIGl0XHJcbiAgICBpZiAoaXNDaGF0Ym90U3BlYWtpbmcuY3VycmVudCkge1xyXG4gICAgICB1c2VyU3BlZWNoU3ludGhlc2lzPy5jYW5jZWwoKTtcclxuICAgICAgaXNDaGF0Ym90U3BlYWtpbmcuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgICBzZXRJc1dpblNwZWFraW5nKGZhbHNlKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgY2hhdEdQVEFuc3dlciA9IGF3YWl0IGdldENoYXRHcHRBbnN3ZXIodXBkYXRlZE1lc3NhZ2VzKTtcclxuICAgIHNldE1lc3NhZ2VzKFtcclxuICAgICAgLi4udXBkYXRlZE1lc3NhZ2VzLFxyXG4gICAgICB7XHJcbiAgICAgICAgbWVzc2FnZTogY2hhdEdQVEFuc3dlcixcclxuICAgICAgICBzZW5kZXI6ICdDaGF0R1BUJyxcclxuICAgICAgfSxcclxuICAgIF0pO1xyXG4gICAgY2hhdEJvdFNwZWFrKGNoYXRHUFRBbnN3ZXIpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IHVzZXJTcGVhayA9ICgpID0+IHtcclxuICAgIC8vIFN0YXJ0IGxpc3RlbmluZyBjb250aW51b3VzbHlcclxuICAgIFNwZWVjaFJlY29nbml0aW9uLnN0YXJ0TGlzdGVuaW5nKHsgXHJcbiAgICAgIGxhbmd1YWdlOiBzZWxlY3RlZExhbmd1YWdlLFxyXG4gICAgICBjb250aW51b3VzOiB0cnVlIFxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKHRyYW5zY3JpcHQgIT09ICcnKSB7XHJcbiAgICAgIHJlc2V0VHJhbnNjcmlwdCgpO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgXHJcbiAgY29uc3QgdXNlclN0b3BTcGVha2luZyA9ICgpID0+IHtcclxuICAgIFNwZWVjaFJlY29nbml0aW9uLnN0b3BMaXN0ZW5pbmcoKTtcclxuICAgIFxyXG4gICAgLy8gUHJvY2VzcyBhbnkgcGVuZGluZyB0cmFuc2NyaXB0XHJcbiAgICBpZiAodHJhbnNjcmlwdC50cmltKCkpIHtcclxuICAgICAgaGFuZGxlU2VuZCh0cmFuc2NyaXB0KTtcclxuICAgICAgcmVzZXRUcmFuc2NyaXB0KCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIENsZWFyIGFueSBwZW5kaW5nIHBhdXNlIHRpbWVyXHJcbiAgICBpZiAocGF1c2VUaW1lclJlZi5jdXJyZW50KSB7XHJcbiAgICAgIGNsZWFyVGltZW91dChwYXVzZVRpbWVyUmVmLmN1cnJlbnQpO1xyXG4gICAgICBwYXVzZVRpbWVyUmVmLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IHVzZXJDYWxsID0gKCkgPT4ge1xyXG4gICAgaXNVc2VyQ2FsbGluZy5jdXJyZW50ID0gdHJ1ZTtcclxuICAgIHNldElzQ2FsbGluZyhpc1VzZXJDYWxsaW5nLmN1cnJlbnQpO1xyXG5cclxuICAgIGlmICghU3BlZWNoUmVjb2duaXRpb24uYnJvd3NlclN1cHBvcnRzU3BlZWNoUmVjb2duaXRpb24oKSkge1xyXG4gICAgICBzZXRNZXNzYWdlcyhbXHJcbiAgICAgICAgLi4ubWVzc2FnZXMsXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgbWVzc2FnZTogdCgnV2luLmJyb3dzZXJOb3RTdXBwb3J0U3BlZWNoUmVjb2duaXRpb25NZXNzYWdlJyksXHJcbiAgICAgICAgICBzZW5kZXI6ICdDaGF0R1BUJyxcclxuICAgICAgICB9LFxyXG4gICAgICBdKTtcclxuICAgICAgaXNVc2VyQ2FsbGluZy5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgIHNldElzQ2FsbGluZyhpc1VzZXJDYWxsaW5nLmN1cnJlbnQpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZmlyc3RNZXNzYWdlID0gdCgnV2luLmZpcnN0TWVzc2FnZScpO1xyXG4gICAgY29uc3QgZm9ybWF0dGVkTWVzc2FnZSA9IHtcclxuICAgICAgbWVzc2FnZTogZmlyc3RNZXNzYWdlLFxyXG4gICAgICBzZW5kZXI6ICdhc3Npc3RhbnQnLFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCB1cGRhdGVkTWVzc2FnZXMgPSBbLi4ubWVzc2FnZXMsIGZvcm1hdHRlZE1lc3NhZ2VdO1xyXG5cclxuICAgIHNldE1lc3NhZ2VzKHVwZGF0ZWRNZXNzYWdlcyk7XHJcbiAgICBcclxuICAgIC8vIFN0YXJ0IGxpc3RlbmluZyBiZWZvcmUgdGhlIGJvdCBzcGVha3NcclxuICAgIFNwZWVjaFJlY29nbml0aW9uLnN0YXJ0TGlzdGVuaW5nKHsgXHJcbiAgICAgIGxhbmd1YWdlOiBzZWxlY3RlZExhbmd1YWdlLFxyXG4gICAgICBjb250aW51b3VzOiB0cnVlIFxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIGNoYXRCb3RTcGVhayhmaXJzdE1lc3NhZ2UpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IHVwZGF0ZUNhbGxIaXN0b3J5ID0gKCkgPT4ge1xyXG4gICAgaWYgKHVzZXJMb2NhbFN0b3JhZ2UgJiYgbWVzc2FnZXMubGVuZ3RoID4gMSkge1xyXG4gICAgICBjb25zdCBzdG9yYWdlID0gdXNlckxvY2FsU3RvcmFnZS5nZXRJdGVtKCdjYWxsSGlzdG9yeScpXHJcbiAgICAgICAgPyBKU09OLnBhcnNlKHVzZXJMb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnY2FsbEhpc3RvcnknKSBhcyBzdHJpbmcpXHJcbiAgICAgICAgOiBbXTtcclxuICAgICAgY29uc3QgbmV3Q2FsbEhpc3Rvcnk6IENhbGxIaXN0b3J5VHlwZVtdID0gWy4uLnN0b3JhZ2UsIHsgbWVzc2FnZXMsIGRhdGU6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSB9XTtcclxuICAgICAgdXNlckxvY2FsU3RvcmFnZT8uc2V0SXRlbSgnY2FsbEhpc3RvcnknLCBKU09OLnN0cmluZ2lmeShuZXdDYWxsSGlzdG9yeSkpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhhbmdVcCA9ICgpID0+IHtcclxuICAgIC8vIENsZWFyIGFueSBwZW5kaW5nIHBhdXNlIHRpbWVyXHJcbiAgICBpZiAocGF1c2VUaW1lclJlZi5jdXJyZW50KSB7XHJcbiAgICAgIGNsZWFyVGltZW91dChwYXVzZVRpbWVyUmVmLmN1cnJlbnQpO1xyXG4gICAgICBwYXVzZVRpbWVyUmVmLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBEaXNjb25uZWN0IGF1ZGlvIHByb2Nlc3NvciBpZiBhY3RpdmVcclxuICAgIGlmIChzcGVlY2hEZXRlY3RvclJlZi5jdXJyZW50ICYmIGF1ZGlvQ29udGV4dFJlZi5jdXJyZW50ICYmIFxyXG4gICAgICAgIHNwZWVjaERldGVjdG9yUmVmLmN1cnJlbnQuY29udGV4dC5zdGF0ZSAhPT0gJ2Nsb3NlZCcpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBzcGVlY2hEZXRlY3RvclJlZi5jdXJyZW50LmRpc2Nvbm5lY3QoKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAvLyBJZ25vcmUgZXJyb3JzIG9uIGRpc2Nvbm5lY3Rpb25cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBTcGVlY2hSZWNvZ25pdGlvbi5zdG9wTGlzdGVuaW5nKCk7XHJcbiAgICBzZXRNZXNzYWdlcyhkZWZhdWx0TWVzc2FnZSk7XHJcbiAgICBpc1VzZXJDYWxsaW5nLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgIHNldElzQ2FsbGluZyhpc1VzZXJDYWxsaW5nLmN1cnJlbnQpO1xyXG4gICAgY3VycmVudFNwZWVjaENvbnRlbnRSZWYuY3VycmVudCA9ICcnO1xyXG4gICAgXHJcbiAgICBpZiAoaXNDaGF0Ym90U3BlYWtpbmcuY3VycmVudCkge1xyXG4gICAgICB1c2VyU3BlZWNoU3ludGhlc2lzPy5jYW5jZWwoKTtcclxuICAgICAgaXNDaGF0Ym90U3BlYWtpbmcuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgICBzZXRJc1dpblNwZWFraW5nKGZhbHNlKTtcclxuICAgICAgc3BlZWNoVXR0ZXJhbmNlUmVmLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBTcGVlY2hSZWNvZ25pdGlvbi5hYm9ydExpc3RlbmluZygpO1xyXG4gICAgcmVzZXRUcmFuc2NyaXB0KCk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgZW5kQ2FsbCA9ICgpID0+IHtcclxuICAgIGhhbmdVcCgpO1xyXG4gICAgdXBkYXRlQ2FsbEhpc3RvcnkoKTtcclxuICB9O1xyXG5cclxuICBjb25zdCB1cGRhdGVQYXVzZVRocmVzaG9sZCA9IChzZWNvbmRzOiBudW1iZXIpID0+IHtcclxuICAgIGlmIChzZWNvbmRzID49IDAuNSAmJiBzZWNvbmRzIDw9IDUpIHtcclxuICAgICAgc2V0UGF1c2VUaHJlc2hvbGQoc2Vjb25kcyk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxDYWxsQ29udGV4dC5Qcm92aWRlclxyXG4gICAgICB2YWx1ZT17e1xyXG4gICAgICAgIHVzZXJDYWxsLFxyXG4gICAgICAgIHVzZXJTcGVhayxcclxuICAgICAgICB1c2VyU3RvcFNwZWFraW5nLFxyXG4gICAgICAgIGxpc3RlbmluZyxcclxuICAgICAgICBpc0NhbGxpbmcsXHJcbiAgICAgICAgZW5kQ2FsbCxcclxuICAgICAgICBoYW5kbGVTZW5kLFxyXG4gICAgICAgIG1lc3NhZ2VzLFxyXG4gICAgICAgIGlzQ2hhdGJvdFNwZWFraW5nOiBpc1dpblNwZWFraW5nLFxyXG4gICAgICAgIHBhdXNlVGhyZXNob2xkLFxyXG4gICAgICAgIHNldFBhdXNlVGhyZXNob2xkOiB1cGRhdGVQYXVzZVRocmVzaG9sZCxcclxuICAgICAgfX1cclxuICAgID5cclxuICAgICAge2NoaWxkcmVufVxyXG4gICAgPC9DYWxsQ29udGV4dC5Qcm92aWRlcj5cclxuICApO1xyXG59O1xyXG5leHBvcnQgY29uc3QgdXNlQ2FsbE1hbmFnZXIgPSAoKSA9PiB7XHJcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoQ2FsbENvbnRleHQpO1xyXG4gIGlmIChjb250ZXh0ID09PSB1bmRlZmluZWQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcigndXNlQ2FsbE1hbmFnZXIgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIENhbGxNYW5hZ2VyJyk7XHJcbiAgfVxyXG4gIHJldHVybiBjb250ZXh0O1xyXG59O1xyXG5leHBvcnQgZGVmYXVsdCBDYWxsTWFuYWdlcjsiXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwidXNlUmVmIiwiU3BlZWNoUmVjb2duaXRpb24iLCJ1c2VTcGVlY2hSZWNvZ25pdGlvbiIsInVzZVRyYW5zbGF0aW9uIiwidXNlTGFuZ3VhZ2UiLCJnZXRDaGF0R3B0QW5zd2VyIiwiQ2FsbENvbnRleHQiLCJ1bmRlZmluZWQiLCJDYWxsTWFuYWdlciIsImNoaWxkcmVuIiwiaXNVc2VyQ2FsbGluZyIsImlzQ2hhdGJvdFNwZWFraW5nIiwic3BlZWNoVXR0ZXJhbmNlUmVmIiwicGF1c2VUaW1lclJlZiIsImxhc3RUcmFuc2NyaXB0UmVmIiwicGF1c2VUaHJlc2hvbGQiLCJzZXRQYXVzZVRocmVzaG9sZCIsImlzSGFuZGxpbmdJbnRlcnJ1cHRpb24iLCJib3RTcGVlY2hTdGFydFRpbWVSZWYiLCJjb29sZG93blBlcmlvZE1zIiwiYXVkaW9Db250ZXh0UmVmIiwic3BlZWNoRGV0ZWN0b3JSZWYiLCJpc1VzZXJTcGVha2luZ1JlZiIsImVuZXJneVRocmVzaG9sZFJlZiIsImN1cnJlbnRTcGVlY2hDb250ZW50UmVmIiwiY29tbWFuZHMiLCJjb21tYW5kIiwiY2FsbGJhY2siLCJ0cmltIiwiY3VycmVudCIsImhhbmRsZVVzZXJTcGVlY2giLCJpc1dpblNwZWFraW5nIiwic2V0SXNXaW5TcGVha2luZyIsImlzQ2FsbGluZyIsInNldElzQ2FsbGluZyIsInRyYW5zY3JpcHQiLCJyZXNldFRyYW5zY3JpcHQiLCJsaXN0ZW5pbmciLCJ0IiwidXNlclNwZWVjaFN5bnRoZXNpcyIsInNldFVzZXJTcGVlY2hTeW50aGVzaXMiLCJ1c2VyTG9jYWxTdG9yYWdlIiwic2V0VXNlckxvY2FsU3RvcmFnZSIsInNlbGVjdGVkTGFuZ3VhZ2UiLCJkZWZhdWx0SW50cm9kdWN0aW9uIiwiZGVmYXVsdE1lc3NhZ2UiLCJtZXNzYWdlIiwic2VuZGVyIiwibWVzc2FnZXMiLCJzZXRNZXNzYWdlcyIsIkF1ZGlvQ29udGV4dCIsIndpbmRvdyIsIndlYmtpdEF1ZGlvQ29udGV4dCIsInNldHVwQXVkaW9Qcm9jZXNzaW5nIiwiZXJyb3IiLCJjb25zb2xlIiwic3RhdGUiLCJjbG9zZSIsInN0cmVhbSIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImdldFVzZXJNZWRpYSIsImF1ZGlvIiwiZWNob0NhbmNlbGxhdGlvbiIsIm5vaXNlU3VwcHJlc3Npb24iLCJhdXRvR2FpbkNvbnRyb2wiLCJtaWNTb3VyY2UiLCJjcmVhdGVNZWRpYVN0cmVhbVNvdXJjZSIsInByb2Nlc3NvciIsImNyZWF0ZVNjcmlwdFByb2Nlc3NvciIsImNvbm5lY3QiLCJvbmF1ZGlvcHJvY2VzcyIsImUiLCJ0aW1lU2luY2VCb3RTdGFydGVkIiwiRGF0ZSIsIm5vdyIsImlucHV0IiwiaW5wdXRCdWZmZXIiLCJnZXRDaGFubmVsRGF0YSIsInNwZWVjaEVuZXJneSIsImNhbGN1bGF0ZVNwZWVjaEVuZXJneSIsInNldFRpbWVvdXQiLCJsb2ciLCJoYW5kbGVJbnRlcnJ1cHRpb24iLCJnYWluTm9kZSIsImNyZWF0ZUdhaW4iLCJnYWluIiwidmFsdWUiLCJkZXN0aW5hdGlvbiIsImRpc2Nvbm5lY3QiLCJidWZmZXIiLCJzdW0iLCJidWZmZXJMZW5ndGgiLCJsZW5ndGgiLCJpIiwiTWF0aCIsImFicyIsInNwZWVjaFN5bnRoZXNpcyIsImxvY2FsU3RvcmFnZSIsImVuZENhbGwiLCJpc0VjaG9PZkJvdFNwZWVjaCIsImNsZWFyVGltZW91dCIsImhhbmRsZVNlbmQiLCJ0cmFuc2NyaXB0VGV4dCIsIm5vcm1hbGl6ZVRleHQiLCJ0ZXh0IiwidG9Mb3dlckNhc2UiLCJyZXBsYWNlIiwibm9ybWFsaXplZFRyYW5zY3JpcHQiLCJub3JtYWxpemVkQm90U3BlZWNoIiwiaW5jbHVkZXMiLCJjYW5jZWwiLCJ1c2VySW5wdXQiLCJjaGF0Qm90U3BlYWsiLCJicm93c2VyU3VwcG9ydHNTcGVlY2hSZWNvZ25pdGlvbiIsInNwZWFrIiwiU3BlZWNoU3ludGhlc2lzVXR0ZXJhbmNlIiwidXR0ZXJhbmNlIiwibGFuZyIsIm9uc3RhcnQiLCJoYW5kbGVDaGF0Ym90U3BlZWNoU3RhcnQiLCJvbmVuZCIsImhhbmRsZUNoYXRib3RTcGVlY2hFbmQiLCJ2b2x1bWUiLCJyYXRlIiwicGl0Y2giLCJzdGFydExpc3RlbmluZyIsImxhbmd1YWdlIiwiY29udGludW91cyIsImZvcm1hdHRlZE1lc3NhZ2UiLCJ1cGRhdGVkTWVzc2FnZXMiLCJjaGF0R1BUQW5zd2VyIiwidXNlclNwZWFrIiwidXNlclN0b3BTcGVha2luZyIsInN0b3BMaXN0ZW5pbmciLCJ1c2VyQ2FsbCIsImZpcnN0TWVzc2FnZSIsInVwZGF0ZUNhbGxIaXN0b3J5Iiwic3RvcmFnZSIsImdldEl0ZW0iLCJKU09OIiwicGFyc2UiLCJuZXdDYWxsSGlzdG9yeSIsImRhdGUiLCJ0b0xvY2FsZVN0cmluZyIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJoYW5nVXAiLCJjb250ZXh0IiwiYWJvcnRMaXN0ZW5pbmciLCJ1cGRhdGVQYXVzZVRocmVzaG9sZCIsInNlY29uZHMiLCJQcm92aWRlciIsInVzZUNhbGxNYW5hZ2VyIiwiRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/CallManager.tsx\n"));

/***/ })

});